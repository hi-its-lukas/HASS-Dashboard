Hier ist eine detaillierte Analyse und Lösungsvorschläge für das SourceBuffer-Problem.

Root-Cause-Analyse
Basierend auf den Logs und Hex-Dumps ist die wahrscheinlichste Ursache für den SourceBuffer-Fehler die Anwesenheit der Marke hvc1 in den compatible_brands des ftyp-Atoms des Init-Segments.

Konflikt der Marken:

Das Init-Segment deklariert im ftyp-Atom Kompatibilität mit: iso6, hvc1 (HEVC/H.265), avc1 (AVC/H.264), mp41.

Dein Code extrahiert korrekt avcC (H.264 Konfiguration) und sendet den MIME-Type video/mp4; codecs="avc1.640020".

Das Problem: Wenn Browser (insbesondere Safari und Chromium-basierte Browser ohne vollständige HEVC-Hardware-Unterstützung) hvc1 im ftyp sehen, können sie das Init-Segment sofort ablehnen, weil sie davon ausgehen, dass die Datei HEVC-Daten enthält, die sie nicht dekodieren können – selbst wenn der eigentliche Track H.264 ist. Dies ist ein bekanntes Verhalten bei strikten MSE-Implementierungen.

major_brand: dash:

Du hast bereits erkannt, dass dash als major_brand problematisch ist und es korrekt zu isom gepatcht. Das ist notwendig, aber oft nicht ausreichend, wenn compatible_brands immer noch problematische Einträge enthält.

Überlappende Box-Struktur (Verdacht):

Bei der Analyse deiner Hex-Dumps gab es Hinweise, dass die Boxen sehr eng gepackt sind. Die Struktur moov -> mvex und trak scheint jedoch laut deiner Hex-Dumps korrekt ausgerichtet zu sein (Start von trak direkt nach mvex), sofern die Größenangaben stimmen. Der primäre Fehlerpunkt bleibt der ftyp-Header.

Lösungen
1. Code-Fix: hvc1 aus ftyp entfernen
Du musst nicht nur die major_brand, sondern auch die compatible_brands bereinigen. Erweitere deine Funktion fixFtypForMSE in lib/streaming/protect-livestream.ts wie folgt:

TypeScript

function fixFtypForMSE(initSegment: Buffer): Buffer {
  if (initSegment.length < 12) return initSegment

  const boxType = initSegment.readUInt32BE(4)
  if (boxType !== 0x66747970) return initSegment // Not ftyp

  // Erstelle eine Kopie, um das Original nicht zu verändern
  const fixed = Buffer.from(initSegment)
  const size = fixed.readUInt32BE(0)

  // 1. Fix major_brand 'dash' -> 'isom'
  const majorBrand = fixed.subarray(8, 12).toString('ascii')
  if (majorBrand === 'dash') {
    console.log('[ProtectLivestream] Fixing ftyp major_brand from "dash" to "isom"')
    fixed.write('isom', 8, 4, 'ascii')
  }

  // 2. Scan & Fix compatible_brands (ab Offset 16)
  // Entferne 'hvc1' und ersetze es durch 'avc1' (Duplikat ist unschädlich) oder 'iso6'
  for (let i = 16; i < size; i += 4) {
    // Sicherstellen, dass wir nicht über das Pufferende lesen
    if (i + 4 > fixed.length) break; 
    
    const brand = fixed.subarray(i, i + 4).toString('ascii')
    if (brand === 'hvc1') {
      console.log('[ProtectLivestream] Removing incompatible brand "hvc1" from ftyp')
      // Wir überschreiben es mit 'avc1', da dies bereits als unterstützt gilt
      fixed.write('avc1', i, 4, 'ascii')
    }
  }

  return fixed
}
2. Codec-Erkennung verbessern (Antworten auf deine Fragen)
Wie stelle ich definitiv fest, ob HEVC oder H.264? Die sicherste Methode ist das Parsen der stsd (Sample Description) Box innerhalb von moov -> trak -> mdia -> minf -> stbl.

Wenn der Entry-Typ avc1 ist, ist es H.264.

Wenn der Entry-Typ hvc1 oder hev1 ist, ist es HEVC.

Dein aktueller Ansatz (avcC suchen) ist pragmatisch und funktioniert für H.264 gut, da avcC nur in avc1-Containern vorkommen darf.

Ist das Init-Segment valide für MSE? Browser prüfen beim appendBuffer:

ftyp: Sind die Brands unterstützt? (Hier liegt vermutlich dein Fehler).

moov Struktur: Enthält es mvex (für fMP4)? (Ja, ist vorhanden).

Codec-Config: Passt der Inhalt von stsd (z.B. SPS/PPS in avcC) zum angegebenen MIME-Typestring?

Sollte ich Kanal 0 verwenden? Kanal 0 (High Quality) ist bei UniFi Protect oft standardmäßig HEVC (um Bandbreite bei 4K zu sparen), während Kanal 1 (Low/Medium Quality) oft H.264 ist. Wenn du Kanal 0 nutzt, musst du zwingend HEVC im Browser unterstützen (was unter Windows/Edge oft eine kostenpflichtige Extension erfordert und in Chrome/Mac Hardware-Support benötigt). Bleib für maximale Kompatibilität bei Kanal 1 oder stelle sicher, dass die Kamera auf H.264 konfiguriert ist (falls möglich).

Diagnose-Tools
Um das Init-Segment offline genau zu prüfen:

Speichere den Hex-Dump oder den Buffer als .mp4 Datei (nur die 1181 Bytes).

Nutze MP4Box (Teil von GPAC): MP4Box -info init.mp4 – dies zeigt dir genau an, ob die Struktur valide ist und welche Brands gesetzt sind.

Online-Parser: Der von dir genannte Box Inspector ist hervorragend, wenn du den Buffer als Datei hochlädst.

Zusammenfassend: Das Patchen der hvc1-Marke im ftyp-Header sollte das Problem lösen, da der eigentliche Videostrom laut deinen Logs korrekt als H.264 (avcC vorhanden) vorliegt.