Analyse: UniFi Protect Livestream-Integration in HASS-Dashboard

Verbindung zur UniFi Protect API (Authentifizierung und Tokens)

Das Repository hjdhjd/unifi-protect verwendet denselben Authentifizierungsmechanismus wie die UniFi Protect Web-OberflÃ¤che. Es meldet sich per HTTP bei der Protect-Controller-URL an und erhÃ¤lt dabei einen Session-Cookie (TOKEN) sowie einen CSRF-Token. ZunÃ¤chst ruft die Library einen CSRF-Token ab (z.B. via GET /api/auth/csrf oder Root-URL) und speichert Cookie und Token ï¿¼. AnschlieÃŸend erfolgt der Login-POST an /api/auth/login mit Benutzername und Passwort. Ist die Anmeldung erfolgreich (HTTP 200), extrahiert die Library den Session-Cookie (TOKEN=<wert>) aus dem Set-Cookie Header sowie den aktualisierten X-CSRF-Token ï¿¼. Diese werden in this.headers gespeichert und fortan bei allen API-Aufrufen mitgesendet (Cookie im Cookie-Header, CSRF-Token im X-CSRF-Token-Header). Auf diese Weise authentifiziert sich der Code bei weiteren REST-Endpunkte der Protect API, ohne dass jedes Mal neu eingeloggt werden muss. Die Library prÃ¼ft vor jedem Request, ob gÃ¼ltige Tokens vorliegen, und fÃ¼hrt bei Bedarf einen Re-Login durch. Dieses Cookie-basierte Verfahren imitiert die offizielle Web-UI und gewÃ¤hrleistet eine stabile Authentifizierung Ã¼ber lÃ¤ngere Zeit ï¿¼.

Empfehlung: FÃ¼r das HASS-Dashboard sollte ein Ã¤hnlicher Ansatz genutzt werden. Entweder kann direkt die unifi-protect Library zum Login verwendet werden (z.B. await protectApi.login(host, user, pass)), oder man implementiert analog dazu: einen Login-Request mit CSRF-Handling und Session-Cookie. Wichtig ist, den erhaltenen Session-Cookie und CSRF-Token global zu speichern und bei allen Folgeanfragen (inklusive WebSocket-Verbindungen) zu nutzen. Im HASS-Dashboard-Code ist bereits zu sehen, dass fÃ¼r UniFi Access ein Agent mit rejectUnauthorized:false verwendet wird ï¿¼ â€“ Ã¤hnlich geht die unifi-protect Library vor, um self-signed Zertifikate zu tolerieren. Auch wird dort ein API-Key genutzt (offizielle Protect Integration API). Allerdings deckt die Integrations-API Livestreams nicht direkt ab, daher ist die Cookie-Sitzung fÃ¼r den inoffiziellen WebSocket-Stream nÃ¶tig. Falls im Dashboard bereits ein Protect-API-Key (fÃ¼r Integration v1 API) vorhanden ist ï¿¼, kann dieser weiterhin fÃ¼r Datenabfragen (Kameras, Events) genutzt werden. FÃ¼r den Livestream-Zugriff muss jedoch die Session-Methode herangezogen werden, da der Livestream-WebSocket keinen API-Key, sondern die laufende Session erwartet. Zusammengefasst: Login mit gÃ¼ltigen Credentials initiieren, Cookie und Token sichern, und diese fÃ¼r alle Protect-Requests und WebSockets einsetzen. Dies sorgt fÃ¼r eine stabile Verbindung zur Protect-API ohne stÃ¤ndige Neuanmeldung.

Livestream-Initialisierung und -Bereitstellung (RTSP vs. WebSocket)

Anders als viele Integrationen, die RTSP-Streams der Kameras nutzen, setzt hjdhjd/unifi-protect auf die Livestream-API von UniFi Protect Ã¼ber WebSocket. Das ist nicht einfach der RTSP-Link der Kamera, sondern ein separater Endpunkt, der direkt den H.264/H.265-Video-Stream liefert ï¿¼. Die Library implementiert als erste eine vollstÃ¤ndige Nutzung dieser Livestream-API â€“ eine Schnittstelle, die Ubiquiti zwar in der Web-UI nutzt, aber nicht dokumentiert ist. Ãœber einen REST-Call an /proxy/protect/api/ws/livestream (via getWsEndpoint("livestream")) erhÃ¤lt der Code eine temporÃ¤re WebSocket-URL, die den Livestream enthÃ¤lt ï¿¼ ï¿¼. Diese URL wird anschlieÃŸend per WebSocket verbunden, um den Videostream abzurufen. Vorteil: Das Video kommt in Echtzeit und mit minimaler Latenz Ã¼ber den WebSocket-Kanal, ohne dass ein zusÃ¤tzlicher Auth-Handshake nÃ¶tig wÃ¤re (die Session ist bereits autorisiert) ï¿¼.

Unter der Haube schickt der Protect-Controller einen H.264/H.265 Stream im fMP4-Format Ã¼ber die WebSocket-Verbindung. Die Library Ã¶ffnet hierfÃ¼r einen WebSocket (mithilfe von Undici) und registriert Event-Listener fÃ¼r einkommende Nachrichten. Jeder empfangene Datenframe enthÃ¤lt einen oder mehrere MP4-â€œBoxenâ€ bzw. Segmente (z.B. Init-Segment, MOOF, MDAT), die zusammen den Videostream bilden ï¿¼ ï¿¼. Die Library stellt sicher, dass zunÃ¤chst ein Initialisierungs-Segment (FTYP+MOOV) gesendet wird, gefolgt von fortlaufenden Fragmenten (MOOF+MDAT fÃ¼r Video/Audio), Ã¤hnlich wie bei HLS, aber in sehr kleinen Zeitscheiben (standardmÃ¤ÃŸig 100â€¯ms) ï¿¼ ï¿¼. Dadurch kann der Stream praktisch live und ohne groÃŸe Pufferung Ã¼bertragen werden. Im Gegensatz zu RTSP entfÃ¤llt hier auch die Notwendigkeit, einen separaten RTSP-Server oder ffmpeg zum Abrufen zu verwenden â€“ die Protect-API liefert die rohen H.264-Daten direkt. Der Entwickler der Library betont, dass dieser Ansatz leichtergewichtig ist und ohne Umwege Ã¼ber RTSP auskommt ï¿¼. TatsÃ¤chlich nutzt die Homebridge-Integration dank dieser Library keinen RTSP-Umweg mehr, was wesentlich ressourcenschonender und weniger fehleranfÃ¤llig ist ï¿¼.

Empfehlung: Im HASS-Dashboard sollte anstelle von RTSP-Streams (die typischerweise mit ffmpeg oder WebRTC-Bridges gearbeitet hÃ¤tten) die WebSocket-Livestream-API verwendet werden. Konkret kann man den Mechanismus aus hjdhjd/unifi-protect Ã¼bernehmen: Ãœber die Protect-REST-API die WebSocket-URL fÃ¼r den Livestream einer bestimmten Kamera abrufen und dann eine WebSocket-Verbindung aufbauen. Die unifi-protect NPM-Library bietet dafÃ¼r bereits Methoden (createLivestream() und .start(cameraId, channel)), die man entweder direkt nutzen oder als Vorlage nehmen kann ï¿¼ ï¿¼. Wichtig ist, den passenden Channel (Kamera-Stream-Profil) zu wÃ¤hlen â€“ z.B. High, Medium oder Low â€“ je nach gewÃ¼nschter AuflÃ¶sung und Codec. FÃ¼r Browser-KompatibilitÃ¤t wÃ¤re es ratsam, den Stream auf H.264 zu belassen (die meisten UniFi-Kameras unterstÃ¼tzen H.264 auf mindestens einem Channel, was fÃ¼r Chrome/Firefox nÃ¶tig ist â€“ H.265 wÃ¼rde z.B. nur in Safari funktionieren). Die WebSocket-LÃ¶sung verspricht eine stabile, sofortige Ãœbertragung ohne die Latenz einer HLS-LÃ¶sung und ohne â€œStream disconnectedâ€-Fehler, da kein externer Prozess stÃ¤ndig neu verbinden muss. Statt periodisch Snapshots oder GIFs im Dashboard anzuzeigen, kann so ein echter kontinuierlicher Videostream integriert werden.

Aufbereitung der Streams fÃ¼r den Browser (Transcoding, MSE, etc.)

Die unifi-protect Library liefert die Videodaten bereits in einem Format, das direkt an Web-Browser weitergereicht werden kann. Es handelt sich um fragmentiertes MP4 (fMP4) mit H.264-Video (und AAC-Audio, falls Ton verfÃ¼gbar ist). Dieses Format lÃ¤sst sich ideal mit Media Source Extensions (MSE) im Browser abspielen. Die Library selbst Ã¼bernimmt kein Transcoding und setzt keine zusÃ¤tzlichen Streaming-Server auf â€“ das ist auch nicht nÃ¶tig. Stattdessen kann der aufrufende Code die ankommenden MP4-Segmente einfach an den Browser durchreichen. Ein Beispiel dafÃ¼r ist das Konzept des â€œSimple Reflectorâ€: ein minimalistischer Proxy-Server, der mittels hjdhjd/unifi-protect die Livestream-Daten abholt und via WebSocket 1:1 zum Browser schickt ï¿¼. Im Browser wiederum lÃ¤uft ein â€œSimple Playerâ€, der diese Daten entgegennimmt und in einen MediaSource-Buffer einspeist.

In hjdhjd/unifi-protect selbst werden die Videosegmente entweder als Node.js-Readable Stream verfÃ¼gbar gemacht (options.useStream=true beim Start) oder als Event-basiertes Buffer-Handling. StandardmÃ¤ÃŸig emitÂ­tiert die Library Events wie initsegment (mit dem Initialisierungsfragment) und segment (fÃ¼r jedes darauffolgende Videofragment) ï¿¼ ï¿¼. Der Entwickler kann diese Buffers z.B. direkt in eine Datei schreiben oder weiterverarbeiten â€“ die Doku nennt explizit, dass man den Livestream in eine Datei pipen, weiterverarbeiten oder woandershin streamen kann ï¿¼. FÃ¼r die Web-Frontends bedeutet das: Sobald die Verbindung steht, bekommt man zunÃ¤chst einen Init-Segment-Buffer (enthÃ¤lt SPS/PPS, Codec-Header etc.) und dann viele kleine Media-Segmente (~100â€¯ms). Im Browser muss man genau diese Reihenfolge an einen MediaSource weitergeben: zuerst das Init-Segment dem SourceBuffer anhÃ¤ngen, dann alle weiteren Segmente nacheinander. Der Codec-String (z.B. â€œavc1.64001F, mp4a.40.2â€) kann aus dem Init-Segment oder dem codec-Event entnommen werden, um den SourceBuffer korrekt zu initialisieren ï¿¼ ï¿¼.

Empfehlung: Im Dashboard-Frontend sollte ein Video-Player mit MSE implementiert werden. Beispielsweise kÃ¶nnte man einen WebSocket vom Browser zum Node.js-Backend Ã¶ffnen, der die BinÃ¤rdaten des Videostreams empfÃ¤ngt (Ã¤hnlich wie beim Simple Player). Im Backend startet man pro Client oder pro gestreamter Kamera einen Livestream und leitet die Buffers weiter. Auf der Browser-Seite werden diese dann im richtigen Timing dem SourceBuffer.appendBuffer() hinzugefÃ¼gt. Da die Segmente bereits korrekt fragmentiert sind und mit PTS/DTS versehen, kÃ¼mmert sich der Browser um das Abspielen â€“ es ist kein Javascript-Video-Decoding notwendig, nur das Appendieren. Wichtig: Den MIME-Type korrekt setzen (z.B. video/mp4; codecs="avc1.64001F, mp4a.40.2" entsprechend dem Init-Segment). Falls das Dashboard mehrere Streams gleichzeitig darstellen soll (z.B. Grid View), muss jeweils ein eigener MediaSource+SourceBuffer verwendet werden. Transcoding ist nicht erforderlich, da die Kamera ohnehin H.264 liefert (sofern konfiguriert) und der Browser das dekodieren kann. Somit bleibt die CPU-Belastung gering. Sollte Audio nicht benÃ¶tigt werden, kÃ¶nnte man den Audiostream ignorieren (oder den SourceBuffer nur mit Video-Codecs initialisieren). Insgesamt kann die LÃ¶sung vollstÃ¤ndig in JavaScript/TypeScript umgesetzt werden, ohne externe Tools. Die bestehenden Dashboard-Strukturen (Next.js API-Routes, WebSocket Proxy im server/ws-proxy.ts usw.) kÃ¶nnen dafÃ¼r genutzt werden, um die Video-BinÃ¤rdaten an den Client zu bringen. Dieses Vorgehen stellt sicher, dass der Livestream im Frontend sichtbar ist, ohne merkliche VerzÃ¶gerung und stabil Ã¼ber lange Zeit lÃ¤uft.

VerbindungsabbrÃ¼che und Reconnect-Mechanismen

Ein zentrales Anliegen ist, Stream-AbbrÃ¼che (â€œStream disconnectedâ€) zu vermeiden. Die Library hjdhjd/unifi-protect hat dafÃ¼r mehrere Schutzmechanismen implementiert. Erstens erfolgen alle Verbindungen (HTTP und WS) Ã¼ber einen robusten Client (Undici) mit automatischen Retry-Strategien und Timeout-Handling. Zweitens wird insbesondere fÃ¼r den Livestream-WebSocket ein Heartbeat eingesetzt: Sobald die WebSocket-Verbindung geÃ¶ffnet ist, startet ein Timer, der in regelmÃ¤ÃŸigen AbstÃ¤nden prÃ¼ft, ob Daten eintreffen ï¿¼ ï¿¼. Bleiben Ã¼ber einen definierten Zeitraum (Standard ~3500â€¯ms) alle neuen Videopakete aus, loggt die Library eine Warnung (â€œlivestream API is not respondingâ€) und schlieÃŸt die WebSocket-Verbindung proaktiv ï¿¼. Dieses erzwungene SchlieÃŸen lÃ¶st bei der Library ein close-Event aus, woraufhin Aufrufer reagieren kÃ¶nnen ï¿¼. Im Homebridge-Plugin beispielsweise wird in so einem Fall der Kamera-Stream neu initialisiert, um HÃ¤ngern automatisch zu beheben (das Plugin erkennt wiederholte Timeouts und startet betroffene Streams neu) ï¿¼. Drittens setzt die Protect-API selbst keinen dauerhaften offenen RTSP-Channel voraus, sondern die WebSocket-Streams kÃ¶nnen beliebig oft neu angefordert werden. Die Library kÃ¼mmert sich darum, dass im Falle eines Verbindungsverlusts (z.B. Protect-Neustart oder Netzwerkproblem) die Events-WebSocket fÃ¼r Echtzeit-Events neu aufgebaut wird (Stichwort â€œgraceful WebSocket reconnectionâ€ in den Features) ï¿¼. FÃ¼r die Livestream-WebSockets ist ein automatischer Reconnect durch die Library nicht eingebaut â€“ hier ist es Aufgabe der Anwendung, ggf. livestream.start() erneut aufzurufen, falls gewÃ¼nscht. Allerdings hÃ¤lt die Library die Session-Cookies weiterhin gÃ¼ltig, sodass ein erneutes Starten sofort wieder verbinden kann, sofern die Session nicht abgelaufen ist.

Empfehlung: Diese Mechanismen sollten ins HASS-Dashboard Ã¼bernommen werden, um maximale StabilitÃ¤t zu erreichen. Konkret:
	â€¢	Heartbeat/Timeout: Implementieren Sie einen Ã¤hnlichen Watchdog im Dashboard-Backend. Da hjdhjd/unifi-protect dies intern macht, kÃ¶nnten Sie entweder die Library nutzen und auf das close-Event des ProtectLivestream hÃ¶ren ï¿¼, oder â€“ falls Sie eigene WebSocket-Handling schreiben â€“ einen Timer setzen, der lastPacketTimestamp Ã¼berwacht. So kann bei einem HÃ¤nger (kein Datenempfang mehr) die Verbindung geschlossen und neu aufgebaut werden, bevor der Frontend-Player einfriert.
	â€¢	Reconnect-Logik: Wenn ein Stream unerwartet schlieÃŸt, sollte das Dashboard mÃ¶glichst automatisch einen neuen Verbindungsversuch starten (vielleicht mit kurzem Backoff, um Endlosschleifen zu vermeiden). Da die Protect-API schnell reagiert, kann ein sofortiges Neuaufsetzen des Streams oft nahtlos weiterlaufen. Falls die AbbrÃ¼che von der Kamera-Seite kommen, kÃ¶nnte man evtl. nach einigen Fehlversuchen aufgeben oder dem Nutzer eine Meldung zeigen.
	â€¢	Fehlerbehandlung: Alle Netzwerkzugriffe sollten try-catch umschlossen sein und Fehler loggen, wie es die Library tut (bei HTTP-Fehlern werden Statuscodes geloggt ï¿¼, bei WebSocket-Fehlern ausfÃ¼hrliche Infos ausgegeben ï¿¼). Dies hilft, Ursachen von â€œStream disconnectedâ€ zu diagnostizieren (z.B. Timeout vs. Auth-Fehler).
	â€¢	Schonende Ressourcen-Nutzung: Wenn ein Nutzer den Stream nicht mehr ansieht (z.B. Tab geschlossen oder Kamera ausgeblendet), sollte das Dashboard den zugehÃ¶rigen Livestream stoppen (livestream.stop() aufrufen oder WebSocket schlieÃŸen), um Bandbreite und CPU zu sparen ï¿¼ ï¿¼. Die Library gibt den Stream sofort frei, und bei erneutem Bedarf kann einfach ein neuer Livestream gestartet werden.

Durch diese MaÃŸnahmen â€“ inspiriert von den ausgereiften Mechanismen in hjdhjd/unifi-protect â€“ bleibt die VideoÃ¼bertragung auch in einem langfristig laufenden Dashboard stabil. Die Benutzer sollten keinen â€œStream disconnectedâ€-Fehler mehr sehen, da das System entweder kontinuierlich Daten liefert oder sich im Hintergrund selbst neu verbindet, bevor es der Nutzer merkt.

Architektur und Bibliothekswahl (ffmpeg, Streaming-Server, Socket-Handling)

Ein Vergleich der Architekturen zeigt deutlich Unterschiede: hjdhjd/unifi-protect verfolgt einen minimalistischen, Node.js-internen Ansatz, wÃ¤hrend alternative LÃ¶sungen oft externe Tools einbinden. Das hjdhjd-Projekt kommt ohne ffmpeg oder sonstige Transcoder aus â€“ nirgends im Code wird ein externer Prozess gestartet. Stattdessen wird die Videodatenverarbeitung komplett in JavaScript/TypeScript erledigt, was dank des bereitgestellten H.264-Streams mÃ¶glich ist. FÃ¼r HomeKit Secure Video etwa musste frÃ¼her hÃ¤ufig ffmpeg genutzt werden, um RTSP von den Kameras umzuwandeln; mit dieser Library konnte der Entwickler aber direkt den H.264-Stream in HomeKit einspeisen, was deutlich weniger Overhead bedeutet ï¿¼. Im Dashboard-Kontext heiÃŸt das: Man muss keinen eigenen Streaming-Server (wie z.B. einen RTSP-to-HLS Konverter oder WebRTC-Gateway) betreiben. Die Protect-Controller Ã¼bernimmt die Stream-Auslieferung, und das Dashboard muss sie nur annehmen und weiterleiten. Das spart KomplexitÃ¤t und potentielle Fehlerquellen.

Auch beim Socket-Handling hat unifi-protect klare Entscheidungen getroffen: Es nutzt WebSockets Ã¼ber HTTP/1.1 (kein HTTP/2) fÃ¼r Streams und Events. Durch die Verwendung des Undici-Clients kann es Low-Level steuern (z.B. pipelining=0, kein Keep-Alive fÃ¼r WS, um saubere Trennung zu gewÃ¤hrleisten) ï¿¼. Dieses fine-tuning stellt sicher, dass beispielsweise ein Stream-WebSocket bei Bedarf sofort getrennt werden kann, ohne dass ein HTTP/2-Multiplexing dazwischenfunkt. Im HASS-Dashboard ist bereits ein WebSocket-Proxy vorgesehen (server/ws-proxy.ts), der vermutlich Benachrichtigungen weiterleitet. Diesen kÃ¶nnte man erweitern oder parallel einen neuen Pfad schaffen, der BinÃ¤r-WebSockets fÃ¼r die Videodaten unterstÃ¼tzt. Alternativ kÃ¶nnte pro Kamera ein eigener Endpoint (z.B. /api/unifi/protect/stream/<camId>) implementiert werden, der beim Aufruf serverseitig die Library nutzt und dann auf einen Upgrade zu WebSocket wechselt, um Daten zu pushen. Wichtig ist hier, eine effiziente Broadcast-Strategie zu wÃ¤hlen, falls mehrere Clients denselben Stream sehen wollen. Evtl. kann man einen einzigen Livestream von Protect beziehen und die Daten an mehrere WebSocket-Clients verteilen, um den NVR zu entlasten.

Zusammengefasst vermeidet das hjdhjd/unifi-protect-Design zusÃ¤tzliche AbhÃ¤ngigkeiten und verlÃ¤sst sich auf Node-FÃ¤higkeiten und die Kamera-Streams selbst. Dies ist auch fÃ¼r das Dashboard zu empfehlen: anstatt auf z.B. GStreamer, ffmpeg oder externe HLS-Server zu setzen (die alle â€œStream disconnectedâ€-Issues mit sich bringen kÃ¶nnten), so viel wie mÃ¶glich mit eingebauter FunktionalitÃ¤t lÃ¶sen. Node 20+ in Kombination mit der unifi-protect Library oder eigenen, davon abgeleiteten Modulen, bietet genug Leistung, um mehrere Kamerastreams gleichzeitig zu handeln.

Konkrete Empfehlungen fÃ¼r HASS-Dashboard
	1.	Verwendung der unifi-protect Library: Ziehen Sie in Betracht, die NPM-Bibliothek unifi-protect direkt ins Projekt zu integrieren. Sie ist modular und gut getestet (â€œit just worksâ€ ï¿¼). Mit ihr kÃ¶nnen Sie Authentifizierung, Kamera-Listing, Event-Updates und insbesondere Livestreams mit minimalem eigenen Code nutzen. Beispielsweise kÃ¶nnen Sie beim Laden der Dashboard-Seite im Backend einen ProtectApi initialisieren, login() ausfÃ¼hren und dann bei Bedarf createLivestream() fÃ¼r die gewÃ¼nschte Kamera aufrufen. Die Library liefert Ihnen dann z.B. einen Readable-Stream der Videoausgabe, den Sie einfach Ã¼ber Ihren bestehenden WebSocket an den Browser schicken kÃ¶nnen. Dadurch Ã¼bernehmen Sie automatisch alle Vorteile (Token-Handling, Reconnect-Logik, Parsing der MP4-Boxen) ohne alles neu schreiben zu mÃ¼ssen. Falls eine vollstÃ¤ndige Integration der Library nicht mÃ¶glich ist, orientieren Sie sich eng an deren Code â€“ insbesondere protect-api.ts und protect-api-livestream.ts â€“ um nichts zu Ã¼bersehen (z.B. CSRF-Token-Beschaffung, URL-Aufbau mit /proxy/protect/, Parameter wie rebaseTimestampsToZero im Livestream-Aufruf etc. ï¿¼ ï¿¼).
	2.	Livestream via WebSocket ans Frontend weiterleiten: Implementieren Sie eine Pipeline, die dem Muster Protect -> Node (Dashboard) -> Browser folgt. Konkret: Der Dashboard-Server holt den Stream von Protect (Ã¼ber die Library) und gibt die Daten unverÃ¤ndert an den Browser. HierfÃ¼r kann ein WebSocket-Endpunkt im Dashboard geschaffen werden (z.B. ws://<dashboard>/api/unifi/stream?camera=<id>). Sobald ein Client diesen Socket Ã¶ffnet, startet der Server im Hintergrund den ProtectLivestream.start(cameraId) und beginnt, die empfangenen Buffers Ã¼ber den WebSocket als BinÃ¤rframes zu senden. Auf Client-Seite fangen Sie diese Frames ab, puffern sie und fÃ¼gen sie dem MediaSource hinzu. Denken Sie daran, gleich zu Beginn nach Verbindungsaufbau das Init-Segment zu senden (die Library pusht es als erstes Segment) und auf Client-Seite dieses dem SourceBuffer voranzustellen, bevor die laufenden Segmente appended werden. Dieses Vorgehen wurde in der Community bereits erfolgreich demonstriert â€“ wie erwÃ¤hnt, Simple Reflector/Player arbeiten genauso ï¿¼. Wichtig: Im Unterschied zu typischen Text-WebSockets muss hier der Server den Sec-WebSocket-Protocol nicht auf JSON setzen, sondern BinÃ¤rdaten (Node Buffer/ArrayBuffer) durchreichen. Achten Sie auf Backpressure â€“ Nodeâ€™s WebSocket hat dafÃ¼r Mechanismen (z.B. socket.pause()), aber da die Daten in kleinen Happen kommen (~alle 100ms), sollte es unkritisch sein.
	3.	Fehlertoleranz und Nutzer-Feedback: Integrieren Sie die erwÃ¤hnten Reconnect-Strategien. Beispielsweise kann der Server nach einem Verbindungsverlust automatisch versuchen, den Stream neu zu holen (evtl. nach 1-2 Sekunden Delay). Sie kÃ¶nnten im Frontend einen kurzen Indikator anzeigen (â€œreconnectingâ€¦â€) und den Video-Tag pausieren lassen, bis der neue Init-Segment da ist, um Artefakte zu vermeiden. Da die Library Livestreams ohne zusÃ¤tzliche Auth neu starten kann (Session bleibt gÃ¼ltig), wird der zweite Verbindungsaufbau in der Regel klappen, sofern der NVR erreichbar ist. Falls jedoch hÃ¤ufiger AbbrÃ¼che auftreten, kÃ¶nnte man Ã¼berlegen, im Hintergrund ggf. die Kamera neu zu laden oder â€“ wie Homebridge es macht â€“ nach X FehlschlÃ¤gen einen Reset auszulÃ¶sen (das dÃ¼rfte im Dashboard aber selten nÃ¶tig sein). In jedem Fall sollte ein geschlossenes WebSocket im Dashboard-Backend auch den Browser informieren (onclose), sodass dieser weiÃŸ, dass der Stream zu Ende ist oder neu aufgebaut werden muss. Da die Library ein close-Event ausgibt, kann der Backend-Code an dieser Stelle den Browser-Clients z.B. eine finale Nachricht schicken (â€œEOSâ€ â€“ end of stream), damit der Player darauf reagieren kann. Mit diesen Signalen ausgestattet, kann der Dashboard-Client vollautomatisch und fÃ¼r den Nutzer transparente Wiederverbindungen durchfÃ¼hren, anstatt einfach â€œStream disconnectedâ€ stehen zu lassen.
	4.	Codebausteine Ã¼bernehmen: Einige konkrete Stellen aus hjdhjd/unifi-protect sind besonders wertvoll:
	â€¢	Die Login-Logik in loginController() ï¿¼ ï¿¼, um CSRF und Cookies korrekt zu managen. Diese kÃ¶nnte man nahezu 1:1 Ã¼bernehmen (ggf. angepasst an Fetch statt Undici, falls nÃ¶tig).
	â€¢	Die Parameter fÃ¼r den Livestream-WebSocket: In launchLivestream() werden Query-Parameter wie fragmentDurationMillis=100, rebaseTimestampsToZero=true, type=fmp4, chunkSize=4096 gesetzt ï¿¼ ï¿¼. Es empfiehlt sich, dieselben Defaults zu verwenden, da sie erprobt sind. Insbesondere allowPartialGOP und progressive sind aktiviert â€“ diese Optionen reduzieren Latenz, indem sie auch mitten im GOP einsteigen kÃ¶nnen.
	â€¢	Der Parsing- und Zusammenbau-Algorithmus (processLivestream()): Falls Sie auf die Library verzichten und selbst den WebSocket lesen, ist es wichtig, die Byte-Stream korrekt zusammenzusetzen. Der Code zeigt, dass jedes Datenpaket einen 1-Byte Header und 3-Byte LÃ¤ngenfeld hat ï¿¼ ï¿¼. Danach folgen die eigentlichen MP4-Box-Daten. Die Header-Werte (247â€“255) definieren die Art des Pakets (Timestamp, CodecInfo, Init, Moof, Mdat, etc.) ï¿¼. Sie kÃ¶nnen diesen Code im Grunde Ã¼bernehmen, um die eingehenden Bytes zu entschlÃ¼sseln. Allerdings: Wenn Sie die Library nutzen, erledigt sie das bereits und gibt Ihnen fertig zusammengesetzte Segmente. In jedem Fall sollte dieser Teil zuverlÃ¤ssig implementiert sein, da sonst fehlerhafte Streams die Folge wÃ¤ren.
	â€¢	Die Heartbeat-Methode: Zeilenweise Ãœbernahme ist nicht nÃ¶tig, aber vom Prinzip her kÃ¶nnen Sie den in open Event gesetzten Timer aus launchLivestream adaptieren ï¿¼ ï¿¼. Dadurch erkennen Sie hÃ¤ngende Streams.
	â€¢	Logging: Die Library nutzt ein Logging-Interface (konfigurierbar). FÃ¼r das Dashboard kÃ¶nnten Sie wichtige Ereignisse (login success/fail, stream start/stop, WS error, codec info received) in der Konsole oder einem Logfile festhalten. Dies hilft beim Debuggen spÃ¤ter.

AbschlieÃŸend lÃ¤sst sich sagen, dass hjdhjd/unifi-protect bereits alle wichtigen Funktionen fÃ¼r einen robusten UniFi-Video-Stream liefert. Durch Ãœbernahme dieser AnsÃ¤tze â€“ Cookie-Authentifizierung, WebSocket-Livestream mit fMP4, MSE-Ausgabe im Browser und automatische Reconnects â€“ kann das hi-its-lukas/HASS-Dashboard die UniFi Protect Kamera-Streams direkt, verzÃ¶gerungsarm und stabil einbinden. Die typischen Abbruch-Probleme von RTSP/FFmpeg entfallen, weil die LÃ¶sung denselben Mechanismus wie die originale Protect-Web-App verwendet. Dies dÃ¼rfte die ZuverlÃ¤ssigkeit erheblich steigern und dem Nutzer ein nahtloses Erlebnis (stÃ¤ndiger Live-Stream ohne â€œStream disconnectedâ€) bieten. ğŸš€

Quellen: Die Analyse basiert auf der UniFi Protect API Library von hjdhjd ï¿¼ ï¿¼ sowie AuszÃ¼gen aus dem HASS-Dashboard-Code und dessen Umgang mit UniFi-APIs. Details zum Livestream-Protokoll (fMP4 Ã¼ber WebSocket) und Best Practices wurden dem Source Code der Library entnommen ï¿¼ ï¿¼, ergÃ¤nzt durch Hinweise aus der Homebridge-Implementierung und Community-Beispielen ï¿¼ ï¿¼. Diese AnsÃ¤tze kÃ¶nnen im HASS-Dashboard gezielt angewendet werden, um das gewÃ¼nschte Ergebnis â€“ einen zuverlÃ¤ssigen Live-Stream der UniFi Protect Kameras im Frontend â€“ zu erreichen.